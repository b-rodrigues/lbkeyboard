---
title: "Optimizing Keyboard Layouts for Luxembourg"
author: "lbkeyboard"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Optimizing Keyboard Layouts for Luxembourg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4,
  cache = TRUE
)
library(lbkeyboard)
```

## Abstract

Luxembourg presents a unique linguistic environment where four languages—French, 
German, Luxembourgish, and English—are used daily. This analysis uses genetic 
algorithm optimization to find keyboard layouts that minimize typing effort 
across all four languages. We compare unconstrained optimization with 
constrained variants based on QWERTZ and BÉPO, providing practical 
recommendations for different user needs.

## Introduction

The standard keyboard layouts (QWERTY, QWERTZ, AZERTY) were designed for 
mechanical typewriters and single-language use. Luxembourg's multilingual 
environment creates a unique challenge: a keyboard layout must work efficiently 
for French (the most common written language), German (widely used in business), 
Luxembourgish (the national language), and English (used internationally).

This vignette presents a systematic optimization study using the `lbkeyboard` 
package's genetic algorithm, which employs a Carpalx-inspired effort model 
considering:

- **Base key effort**: Position-dependent cost based on row and finger
- **Same-finger bigrams**: High penalty for consecutive keys on same finger
- **Same-hand sequences**: Moderate penalty with roll direction consideration
- **Row changes**: Penalty for vertical finger movement within a hand

## Data and Methodology

### Text Samples

We use representative text samples from all four languages:

```{r load-data}
data("french")
data("german")
data("english")
data("luxembourguish")
```

```{r sample-sizes, echo=FALSE}
sample_info <- data.frame(
  Language = c("French", "German", "Luxembourgish", "English"),
  Characters = c(nchar(french), nchar(german), 
                 nchar(luxembourguish), nchar(english))
)
knitr::kable(sample_info, caption = "Text sample sizes by language")
```

### Language Weighting

Based on estimated language usage in Luxembourg, we weight the samples:

- **French**: 45% (primary written language)
- **German**: 25% (business and media)
- **Luxembourgish**: 20% (daily communication)
- **English**: 10% (international use)

```{r combine-texts}
all_texts <- c(
  rep(french, 4),
  rep(german, 2),
  rep(luxembourguish, 2),
  english
)
total_chars <- sum(nchar(all_texts))
```

The combined corpus contains **`r format(total_chars, big.mark=",")`** characters.

### Letter Frequency Analysis

```{r letter-freq}
freq_all <- letter_freq(paste(all_texts, collapse = " "))
```

```{r freq-table, echo=FALSE}
freq_top <- head(freq_all, 12)
freq_top$frequencies <- round(freq_top$frequencies * 100, 2)
names(freq_top) <- c("Letter", "Count", "Scaled", "Frequency (%)")
knitr::kable(freq_top, caption = "Most frequent letters across all languages")
```

The letter **e** dominates at `r round(freq_all$frequencies[1] * 100, 1)`%, 
followed by **n** (`r round(freq_all$frequencies[2] * 100, 1)`%) and **a** 
(`r round(freq_all$frequencies[3] * 100, 1)`%). This frequency distribution 
guides our optimization toward placing these letters in the most accessible 
positions.

## Optimization Parameters

```{r params}
GENERATIONS <- 200
POPULATION_SIZE <- 80
```

All optimizations use `r GENERATIONS` generations with a population size of 
`r POPULATION_SIZE`. For production use, increasing to 500+ generations may 
yield further improvements.

## Results

### 1. Unconstrained Optimization

We first find the theoretically optimal layout with no constraints:

```{r opt-unconstrained, results='hide'}
result_unconstrained <- optimize_layout(
  text_samples = all_texts,
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r unconstrained-result}
cat("Initial effort:", round(result_unconstrained$initial_effort, 0), "\n")
cat("Final effort:  ", round(result_unconstrained$effort, 0), "\n")
cat("Improvement:   ", round(result_unconstrained$improvement, 1), "%\n")
```

**Unconstrained optimal layout:**

```{r unconstrained-layout}
print_layout(result_unconstrained$layout)
```

This layout achieves a **`r round(result_unconstrained$improvement, 1)`%** 
reduction in typing effort compared to QWERTY.

### 2. Balanced Hands Variant

Adding a hand-balance constraint ensures equal workload distribution:

```{r opt-balanced, results='hide'}
result_balanced <- optimize_layout(
  text_samples = all_texts,
  rules = list(balance_hands(0.5, weight = 2.0)),
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r balanced-result}
cat("Final effort: ", round(result_balanced$effort, 0), "\n")
cat("Improvement:  ", round(result_balanced$improvement, 1), "%\n")
```

```{r balanced-layout}
print_layout(result_balanced$layout)
```

The balanced variant achieves **`r round(result_balanced$improvement, 1)`%** 
improvement while maintaining ergonomic hand distribution.

### 3. QWERTZ-Based Optimization

For users transitioning from Swiss QWERTZ, we explore partial optimizations 
that preserve familiar key positions.

#### 3a. Minimal Constraints (Shortcuts Only)

```{r opt-qwertz-minimal, results='hide'}
result_qwertz_min <- optimize_layout(
  text_samples = all_texts,
  rules = list(
    fix_keys(c("z", "x", "c", "v")),
    balance_hands(0.5, weight = 1.0)
  ),
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r qwertz-min-result}
cat("Fixed keys:   ", result_qwertz_min$n_fixed, "\n")
cat("Improvement:  ", round(result_qwertz_min$improvement, 1), "%\n")
```

```{r qwertz-min-layout}
print_layout(result_qwertz_min$layout)
```

#### 3b. Bottom Row Fixed

```{r opt-qwertz-bottom, results='hide'}
result_qwertz_bottom <- optimize_layout(
  text_samples = all_texts,
  rules = list(
    fix_keys(c("z", "x", "c", "v", "b", "n", "m")),
    balance_hands(0.5, weight = 1.0)
  ),
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r qwertz-bottom-result}
cat("Fixed keys:   ", result_qwertz_bottom$n_fixed, "\n")
cat("Improvement:  ", round(result_qwertz_bottom$improvement, 1), "%\n")
```

```{r qwertz-bottom-layout}
print_layout(result_qwertz_bottom$layout)
```

### 4. BÉPO-Style Optimization

BÉPO places vowels on the left hand and common consonants on the right. We 
apply this philosophy as soft constraints:

```{r opt-bepo, results='hide'}
result_bepo <- optimize_layout(
  text_samples = all_texts,
  rules = list(
    fix_keys(c("z", "x", "c", "v")),
    prefer_hand(c("a", "e", "i", "o", "u"), "left", weight = 3.0),
    prefer_hand(c("t", "s", "r", "n", "l"), "right", weight = 2.0),
    prefer_row(c("e", "t", "a", "n", "i", "s"), 2, weight = 1.5),
    balance_hands(0.5, weight = 1.0)
  ),
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r bepo-result}
cat("Improvement:  ", round(result_bepo$improvement, 1), "%\n")
```

```{r bepo-layout}
print_layout(result_bepo$layout)
```

## Comparison Summary

```{r comparison-table, echo=FALSE}
results <- list(
  "Unconstrained" = result_unconstrained,
  "Balanced Hands" = result_balanced,
  "QWERTZ (shortcuts)" = result_qwertz_min,
  "QWERTZ (bottom row)" = result_qwertz_bottom,
  "BÉPO-style" = result_bepo
)

comparison <- data.frame(
  Layout = names(results),
  `Final Effort` = sapply(results, function(r) round(r$effort, 0)),
  `Improvement (%)` = sapply(results, function(r) round(r$improvement, 1)),
  `Fixed Keys` = sapply(results, function(r) r$n_fixed),
  check.names = FALSE
)

comparison <- comparison[order(comparison$`Final Effort`), ]
comparison$Rank <- seq_len(nrow(comparison))
knitr::kable(comparison, row.names = FALSE,
             caption = "Layout comparison sorted by typing effort")
```

```{r convergence-plot, echo=FALSE, fig.cap="Convergence of unconstrained optimization"}
plot(result_unconstrained$history$generation, 
     result_unconstrained$history$best,
     type = "l", col = "steelblue", lwd = 2,
     xlab = "Generation", ylab = "Effort",
     main = "Optimization Convergence")
lines(result_unconstrained$history$generation, 
      result_unconstrained$history$mean, 
      col = "gray60", lty = 2)
legend("topright", c("Best", "Mean"), 
       col = c("steelblue", "gray60"), lty = c(1, 2), lwd = c(2, 1))
```

## Recommendations

Based on our analysis, we recommend:

### For Maximum Efficiency

Use the **unconstrained** or **balanced hands** layout for the greatest typing 
efficiency improvement (`r round(result_unconstrained$improvement, 0)`-`r round(result_balanced$improvement, 0)`%). 
This requires complete relearning but provides the largest benefit for 
dedicated users.

### For Practical Transition

Use the **QWERTZ (shortcuts only)** layout, which achieves 
**`r round(result_qwertz_min$improvement, 0)`% improvement** while preserving 
Ctrl+Z/X/C/V shortcuts. Only 22 keys need relearning.

### For Minimal Disruption

The **QWERTZ (bottom row fixed)** layout preserves more familiar keys while 
still achieving **`r round(result_qwertz_bottom$improvement, 0)`% improvement**.

## Special Characters

Luxembourg's languages require access to special characters:

| Character | Languages | Suggested Access |
|-----------|-----------|------------------|
| ä, ö, ü | German, Luxembourgish | AltGr + a/o/u |
| ë | Luxembourgish | AltGr + e |
| é, è, ê | French | Dead key or AltGr |
| à, â | French | Dead key or AltGr |

## Number Row

Two configurations are recommended:

1. **Direct numbers** (programming/data entry): 1234567890 on base layer
2. **French-style** (prose writing): Symbols on base layer, numbers via Shift

## Conclusion

This analysis demonstrates that substantial typing efficiency gains 
(`r round(min(sapply(results, function(r) r$improvement)), 0)`-`r round(max(sapply(results, function(r) r$improvement)), 0)`%) 
are achievable for Luxembourg's multilingual environment. The choice of layout 
depends on the user's willingness to relearn and their specific use case.

The optimized layouts place high-frequency letters (e, n, a, s, i, t, r) on the 
home row and strong fingers, while minimizing same-finger bigrams common in 
French and German text.

## Session Info

```{r session-info}
sessionInfo()
```
