---
title: "Optimizing Keyboard Layouts for Luxembourg"
author: "lbkeyboard"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Optimizing Keyboard Layouts for Luxembourg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 4,
  cache = FALSE
)
library(lbkeyboard)
```

## Introduction

Luxembourg's multilingual environment requires a keyboard that works efficiently 
for French, German, Luxembourgish, and English. This vignette demonstrates 
keyboard optimization with **30-key layouts including accented characters** 
(é, è, ä, ü) in direct access.

We present three optimizations:

1. **Unconstrained**: Maximum efficiency (30 movable keys)
2. **Minimal Disruption**: E on home row left index (8 movable keys)
3. **QWERTZ-Based**: Fixed optimal home row (9 movable keys)

## Data Preparation

```{r load-data}
data("french")
data("german")
data("english")
data("luxembourguish")

# Weight by estimated usage in Luxembourg
all_texts <- c(
  rep(french, 4),         # 45% French
  rep(german, 2),         # 25% German
  rep(luxembourguish, 2), # 20% Luxembourgish
  english                 # 10% English
)

cat("Total corpus:", format(sum(nchar(all_texts)), big.mark = ","), "characters\n")
```

```{r freq-analysis}
freq_all <- letter_freq(paste(all_texts, collapse = " "))
```

```{r freq-table, echo=FALSE}
freq_top <- head(freq_all, 10)
freq_top$pct <- paste0(round(freq_top$frequencies * 100, 1), "%")
knitr::kable(freq_top[, c("characters", "total", "pct")],
             col.names = c("Letter", "Count", "Frequency"),
             caption = "Top 10 most frequent characters")
```

## Optimization Parameters

```{r params}
GENERATIONS <- 200
POPULATION_SIZE <- 80
```

## Helper Function: Hand Balance

Calculate what percentage of keystrokes go to each hand:

```{r hand-balance-fn}
calculate_hand_balance <- function(layout, freq_df) {
  # Get layout as data frame
  if (is.list(layout) && "layout" %in% names(layout)) {
    layout_df <- layout$layout
  } else {
    layout_df <- layout
  }
  
  # Determine hand based on column position
  # Columns 0-4 = left hand, 5+ = right hand
  left_keys <- layout_df$key[layout_df$number < 5]
  right_keys <- layout_df$key[layout_df$number >= 5]
  
  # Calculate frequency for each hand
  left_freq <- sum(freq_df$frequencies[freq_df$characters %in% left_keys], na.rm = TRUE)
  right_freq <- sum(freq_df$frequencies[freq_df$characters %in% right_keys], na.rm = TRUE)
  
  # Normalize
  total <- left_freq + right_freq
  list(
    left = round(left_freq / total * 100, 1),
    right = round(right_freq / total * 100, 1)
  )
}
```

---

## 1. Unconstrained 30-Key Optimization

All 30 keys (26 letters + 4 accents) are free to move:

```{r opt-unconstrained, results='hide'}
result_unconstrained <- optimize_layout(
  text_samples = all_texts,
  include_accents = TRUE,
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r unconstrained-result}
cat("Improvement:", round(result_unconstrained$improvement, 1), "%\n")
```

```{r unconstrained-layout}
print_layout(result_unconstrained$layout)
```

```{r heatmap-unconstrained, echo=FALSE, fig.cap="Unconstrained layout - frequency heatmap", fig.width=8, fig.height=4, warning=FALSE}
# Create heatmap helper
make_heatmap <- function(result, freq_df) {
  data(ch_qwertz, envir = environment())
  kb <- ch_qwertz
  letter_rows <- tolower(kb$key) %in% c(letters, "é", "è", "ä", "ü")
  layout_keys <- result$layout$key
  n_update <- min(sum(letter_rows), length(layout_keys))
  kb$key[which(letter_rows)[1:n_update]] <- layout_keys[1:n_update]
  kb$key_label[which(letter_rows)[1:n_update]] <- toupper(layout_keys[1:n_update])
  heatmapize(kb, freq_df) |> ggkeyboard()
}

make_heatmap(result_unconstrained, freq_all)
```

---

## 2. Minimal Disruption (E on Index Finger)

E fixed on home row left index, only top 8 letters movable:

```{r opt-e-index, results='hide'}
# Extended layout with E on home row left index
ext_keys_v2 <- c(
  "q","w","f","r","t","y","u","i","o","p","è",
  "a","s","d","e","g","h","j","k","l","é",
  "z","x","c","v","b","n","m","ä","ü"
)

top_8 <- as.character(freq_all$characters[2:9])
fixed_v2 <- setdiff(ext_keys_v2, top_8)

kb_v2 <- data.frame(
  key = ext_keys_v2,
  key_label = toupper(ext_keys_v2),
  row = c(rep(1, 11), rep(2, 10), rep(3, 9)),
  number = c(0:10, 0:9, 0:8),
  stringsAsFactors = FALSE
)
kb_v2$x_mid <- kb_v2$number + c(0, 0.25, 0.5)[kb_v2$row]
kb_v2$y_mid <- kb_v2$row

result_e_index <- optimize_layout(
  text_samples = all_texts,
  keyboard = kb_v2,
  keys_to_optimize = ext_keys_v2,
  rules = list(fix_keys(fixed_v2)),
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r e-index-result}
cat("Keys to relearn:", 8, "\n")
cat("Improvement:", round(result_e_index$improvement, 1), "%\n")
```

```{r e-index-layout}
print_layout(result_e_index$layout)
```

```{r heatmap-e-index, echo=FALSE, fig.cap="E on Index layout - frequency heatmap", fig.width=8, fig.height=4, warning=FALSE}
make_heatmap(result_e_index, freq_all)
```

---

## 3. QWERTZ-Based with Optimal Home Row

Starting from QWERTZ, we fix the home row to the most frequent letters:
**A S D E U N T R L M**

Only the displaced keys (F, G, H, J, K) and accents need optimization:

```{r opt-qwertz-home, results='hide'}
# QWERTZ-based with optimal home row
ext_keys_v3 <- c(
  "q","w","f","g","h","z","j","i","o","p","è",
  "a","s","d","e","u","n","t","r","l","m",
  "y","x","c","v","b","k","é","ä","ü"
)

movable_v3 <- c("f", "g", "h", "j", "k", "é", "è", "ä", "ü")
fixed_v3 <- setdiff(ext_keys_v3, movable_v3)

kb_v3 <- data.frame(
  key = ext_keys_v3,
  key_label = toupper(ext_keys_v3),
  row = c(rep(1, 11), rep(2, 10), rep(3, 9)),
  number = c(0:10, 0:9, 0:8),
  stringsAsFactors = FALSE
)
kb_v3$x_mid <- kb_v3$number + c(0, 0.25, 0.5)[kb_v3$row]
kb_v3$y_mid <- kb_v3$row

result_qwertz_home <- optimize_layout(
  text_samples = all_texts,
  keyboard = kb_v3,
  keys_to_optimize = ext_keys_v3,
  rules = list(fix_keys(fixed_v3)),
  generations = GENERATIONS,
  population_size = POPULATION_SIZE,
  verbose = FALSE
)
```

```{r qwertz-home-result}
cat("Keys to relearn:", length(movable_v3), "\n")
cat("Improvement:", round(result_qwertz_home$improvement, 1), "%\n")
```

```{r qwertz-home-layout}
print_layout(result_qwertz_home$layout)
```

```{r heatmap-qwertz-home, echo=FALSE, fig.cap="QWERTZ Home Row layout - frequency heatmap", fig.width=8, fig.height=4, warning=FALSE}
make_heatmap(result_qwertz_home, freq_all)
```

---

## Comparison

```{r comparison-table, echo=FALSE}
# Calculate hand balance for each layout
hb1 <- calculate_hand_balance(result_unconstrained, freq_all)
hb2 <- calculate_hand_balance(result_e_index, freq_all)
hb3 <- calculate_hand_balance(result_qwertz_home, freq_all)

comparison <- data.frame(
  Layout = c("Unconstrained", "E on Index", "QWERTZ Home Row"),
  `Keys to Learn` = c(30, 8, 9),
  `Improvement` = c(
    paste0(round(result_unconstrained$improvement, 1), "%"),
    paste0(round(result_e_index$improvement, 1), "%"),
    paste0(round(result_qwertz_home$improvement, 1), "%")
  ),
  `Left Hand` = c(
    paste0(hb1$left, "%"),
    paste0(hb2$left, "%"),
    paste0(hb3$left, "%")
  ),
  `Right Hand` = c(
    paste0(hb1$right, "%"),
    paste0(hb2$right, "%"),
    paste0(hb3$right, "%")
  ),
  check.names = FALSE
)

knitr::kable(comparison, caption = "Layout comparison with hand balance")
```

## Recommendations

| Use Case | Recommended Layout | Improvement |
|----------|-------------------|-------------|
| Maximum efficiency | Unconstrained | ~`r round(result_unconstrained$improvement, 0)`% |
| Minimal relearning | E on Index | ~`r round(result_e_index$improvement, 0)`% |
| QWERTZ familiarity | QWERTZ Home Row | ~`r round(result_qwertz_home$improvement, 0)`% |

All layouts include **É, È, Ä, Ü in direct access** — no dead keys or AltGr needed.

## Session Info

```{r session-info}
sessionInfo()
```
