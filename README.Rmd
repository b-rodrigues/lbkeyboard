---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# lbkeyboard

<!-- badges: start -->
<!-- badges: end -->

lbkeyboard provides tools for **analyzing and optimizing keyboard layouts** 
for Luxembourg and multilingual typing. The package includes:

- **Layout visualization** with heatmaps showing letter frequency
- **Genetic algorithm optimization** using a Carpalx-inspired effort model
- **Composable rules system** for customizing optimization constraints
- Support for French, German, Luxembourgish, and English

## Installation

You can install the development version of lbkeyboard from
[GitHub](https://github.com/b-rodrigues/lbkeyboard) with:

``` r
# install.packages("devtools")
devtools::install_github("b-rodrigues/lbkeyboard")
```

## Layout Visualization

```{r example}
library(lbkeyboard)
```

Here is the BÉPO layout:

```{r}
ggkeyboard(keyboard = afnor_bepo, layout = "iso")
```

and here the AZERTY layout:

```{r}
ggkeyboard(keyboard = afnor_azerty, layout = "iso")
```

AZERTY and BÉPO are the layouts used in France; AZERTY is, by a very wide
margin, the most used layout in France. BÉPO is an optimized layout for the
French layout.

In Luxembourg, the most used layout is the Swiss French (or German, depending on
the user's preferences):

```{r}
ggkeyboard(keyboard = ch_qwertz, layout = "iso")
```

### Heatmaps

It is also possible to generate heatmaps. First, let's load some French text:

```{r}
data("french")
```

Then, let's compute the frequency of the letters:

```{r}
letter_freq_df <- letter_freq(french)
```

Let's add the colours:

```{r}
heatmap_azerty <- heatmapize(afnor_azerty, letter_freq_df)
```

Let's plot the heatmap:

```{r}
ggkeyboard(heatmap_azerty)
```

Let's compare to the BÉPO layout:


```{r}
heatmap_bepo <- heatmapize(afnor_bepo, letter_freq_df)
ggkeyboard(heatmap_bepo)
```

Let's compare heatmaps for Swiss German (QWERTZ) and BÉPO for the German language:

```{r}
data("german")
letter_freq_de <- letter_freq(german)

heatmap_qwertz <- heatmapize(ch_qwertz, letter_freq_de)
heatmap_bepo_de <- heatmapize(afnor_bepo, letter_freq_de)

ggkeyboard(heatmap_qwertz)
ggkeyboard(heatmap_bepo_de)
```

Even though BÉPO is originally a layout optimized for the French language, we
can see from the heatmap that the most frequently used letters are in the home
row, which is not the case for the Swiss German (QWERTZ layout).

Let's also generate some heatmaps for English:


```{r}
data("english")
letter_freq_en <- letter_freq(english)

heatmap_qwertz <- heatmapize(ch_qwertz, letter_freq_en)
heatmap_bepo_en <- heatmapize(afnor_bepo, letter_freq_en)

ggkeyboard(heatmap_qwertz)
ggkeyboard(heatmap_bepo_en)
```

Here again, we see that the BÉPO layout seems to fare better than the QWERTZ
layout.

## Optimization Algorithm

The package includes a genetic algorithm for finding optimal keyboard layouts.
The algorithm uses a **Carpalx-inspired effort model** that considers:

- **Base key effort**: Based on row position, finger strength, and distance from
  home position
- **Same-finger bigrams**: High penalty when consecutive keys use the same
  finger
- **Same-hand sequences**: Moderate penalty, with inward rolls penalized less
  than outward rolls
- **Row changes**: Penalty for reaching between rows on same hand

### Basic Usage

```{r, eval=FALSE}
# Load sample texts
data(french)
data(luxembourguish)

# Optimize layout for multiple languages
result <- optimize_layout(
  text_samples = c(french, luxembourguish),
  generations = 200,
  verbose = TRUE
)

# View the optimized layout in ASCII
print_layout(result$layout)

# Check improvement over starting layout
cat("Improvement:", round(result$improvement, 2), "%\n")
```

### Comparing Layouts

You can compare the typing effort across different keyboard layouts:

```{r, eval=FALSE}
data(afnor_bepo)
data(afnor_azerty)
data(ch_qwertz)

comparison <- compare_layouts(
  keyboards = list(
    BEPO = afnor_bepo,
    AZERTY = afnor_azerty,
    QWERTZ = ch_qwertz
  ),
  text_samples = french
)

print(comparison)
```

### Effort Breakdown

Get detailed breakdown of effort components:

```{r, eval=FALSE}
breakdown <- calculate_layout_effort(
  afnor_bepo,
  french,
  breakdown = TRUE
)

print(breakdown)
```

## Composable Rules System

The optimization algorithm supports a **composable rules system** that lets you
customize constraints and preferences:

### Available Rules

| Rule | Type | Description |
|------|------|-------------|
| `fix_keys()` | Hard | Keys cannot move from initial position |
| `prefer_hand()` | Soft | Penalty if keys not on specified hand |
| `prefer_row()` | Soft | Penalty if keys not on specified row |
| `balance_hands()` | Soft | Penalty for hand usage imbalance |
| `keep_like()` | Soft | Penalty if keys differ from reference layout |

### Example with Rules

```{r, eval=FALSE}
result <- optimize_layout(
  text_samples = french,
  rules = list(
    # Hard constraint: keep Ctrl shortcut keys in place
    fix_keys(c("z", "x", "c", "v")),
    
    # Soft preference: vowels on left hand (weight controls strength)
    prefer_hand(c("a", "e", "i", "o", "u"), "left", weight = 2.0),
    
    # Soft preference: common letters on home row
    prefer_row(c("e", "t", "a", "o", "n"), 2, weight = 1.5),
    
    # Soft preference: balanced hand usage (50/50)
    balance_hands(0.5, weight = 1.0)
  ),
  generations = 200
)

# ASCII visualization
print_layout(result$layout)
```

### Fixed Key Positions

You can also use the simpler `fixed_keys` parameter:

```{r, eval=FALSE}
# Keep home row keys fixed, optimize everything else
result <- optimize_layout(
  text_samples = french,
  fixed_keys = c("a", "s", "d", "f", "j", "k", "l"),
  generations = 200
)

# Check how many keys were optimized
cat("Fixed:", result$n_fixed, "Optimized:", result$n_optimized, "\n")
```

This is useful for:
- Keeping frequently-used keys in familiar positions
- Preserving muscle memory for certain keys
- Partial optimization of existing layouts

### Algorithm Parameters

The genetic algorithm supports tuning:

- `population_size`: Number of candidate layouts (default 100)
- `generations`: Evolution iterations (default 500)
- `mutation_rate`: Probability of mutation (default 0.1)
- `crossover_rate`: Probability of crossover (default 0.8)
- `effort_weights`: Weights for different effort components
- `fixed_keys`: Keys to keep in their original positions
- `rules`: List of composable rule objects

The algorithm is implemented in C++ via Rcpp for efficiency.

## Acknowledgment

This package uses some code from my fork of the
[ggkeyboard](https://github.com/b-rodrigues/ggkeyboard) package (original
package can be found [here](https://github.com/sharlagelfand/ggkeyboard).

